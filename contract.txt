
contract CreateContract {

    struct ContractInfo { 
      string Category;
      string Type;
      string Desc;
      string Name;
      string Email;
      string StartDate;
      string EndDate;
      string CreateDate;
      string IpfsUrl;
      string Sha256;
    }

    mapping(address => bool) internal ownersMap;
    mapping(string => ContractInfo) public allContractsMap;
    mapping(address => string[]) public userContractsMap;
    mapping(address => string[]) public invitedContractsMap;
    mapping(string => address[]) public contractParticipatingUsersMap;
    mapping(address => mapping(string => bool)) public isConfirmed;
    
    
    
    constructor() {
        ownersMap[msg.sender] = true;
    }

    modifier onlyOwner() {
        require(ownersMap[msg.sender], "not an organization owner");
        _;
    }

    function isOwner(address _add) public view returns (bool) {
        return ownersMap[_add];
    }

    function addOwner(address _add) public onlyOwner {
        ownersMap[_add] = true;
    }

    function addContract(string memory _category,
                         string memory _type,
                         string memory _desc,
                         string memory _name,
                         string memory _email,
                         string memory _start_date,
                         string memory _end_date,
                         string memory _create_date,
                         string memory _sha256,
                         string memory _ipfsuri,
                         address[] memory _invitedUsers) public {
        require(bytes(_sha256).length >= 0, "Invalid Document Code.");
        require(bytes(allContractsMap[_sha256].IpfsUrl).length == 0, "Document already exists.");
        ContractInfo memory userContract = ContractInfo(_category, _type, _desc, _name, _email, _start_date, _end_date, _create_date, _ipfsuri, _sha256);
        allContractsMap[_sha256] = userContract;
        userContractsMap[msg.sender].push(_sha256);
        contractParticipatingUsersMap[_sha256].push(msg.sender);
        inviteUsers(_invitedUsers, _sha256);
    }

    function inviteUsers(address[] memory _invitedUsers, string memory _sha256) public {
        for (uint i = 0; i < _invitedUsers.length; i++) {
            address user = _invitedUsers[i];
            require(user != address(0), "invalid user address");
            contractParticipatingUsersMap[_sha256].push(user);
            invitedContractsMap[user].push(_sha256);
            isConfirmed[user][_sha256] = false;
        }
    }

    //get contract details
    function getContract(string memory _sha256) public view returns ( ContractInfo memory ) {
        return allContractsMap[_sha256];
    }

    //get users involved in a contract and accepted status
    function getContractUserAndStatus(string memory _sha256) public view returns ( address[] memory, bool[] memory) {
        address[] memory allUsers = contractParticipatingUsersMap[_sha256];
        bool[] memory statuses = new bool[](allUsers.length);
        for (uint i = 0; i < allUsers.length; i++) {
            address user = allUsers[i];
            statuses[i] = isConfirmed[user][_sha256];
        }
        return (allUsers, statuses);
    }

    //owner created contracts
    function getAllUserContracts() public view returns (ContractInfo[] memory) {
        string[] memory userContracts = userContractsMap[msg.sender];
        ContractInfo[] memory contracts = new ContractInfo[](userContracts.length);
        for (uint i = 0; i < userContracts.length; i++) {
            string memory sha = userContracts[i];
            contracts[i] = allContractsMap[sha];
        }
        return contracts;
    }

    //invited contracts by other contract owners
    function getAllInvitedContractsAndStatus() public view returns (ContractInfo[] memory, bool[] memory) {
        string[] memory invitedContracts = invitedContractsMap[msg.sender];
        ContractInfo[] memory contracts = new ContractInfo[](invitedContracts.length);
        bool[] memory statuses = new bool[](invitedContracts.length);
        for (uint i = 0; i < invitedContracts.length; i++) {
            string memory sha = invitedContracts[i];
            contracts[i] = allContractsMap[sha];
            statuses[i] = isConfirmed[msg.sender][sha];
        }
        return (contracts, statuses);
    }

    //accept invite
    function approveTransaction(string memory _sha256) public {
        isConfirmed[msg.sender][_sha256] = true;
    }
}
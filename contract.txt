// SPDX-License-Identifier: MIT
pragma solidity >=0.8.9 <0.9.0;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/utils/Strings.sol';


contract CreateContract is Ownable {

  using Strings for uint256;
  

  struct structContractInfo { 
      string Category;
      string Desc;
      string Name;
      string Email;
      string StartDate;
      string EndDate;
      string CreateDate;
      string IPFSURI;
  }

    struct userKycInfo { 
      string FirstName;
      string LastName;
      string DOB;
      string Gender;
      string AadhaarNumber;
      string AadhaarFrontURL;
      string AadhaarBackURL;
      string SelfieURL;
      string CreateDate;
  }


  uint256 public ContractCreatePrice = 0 ether;


  mapping(string => structContractInfo) public ContractsMap;
  mapping(address => string[]) public ContractCreatorMap;
  mapping(address => userKycInfo) private userKycMap;

  mapping(string => address[]) public addressesInvoledInContractMap;
  mapping(string => string[]) public emailsInvolvedInContractMap;
  mapping(address => string[]) public signatureNeededMap;
  mapping(address => mapping(string => bool)) public isConfirmed;

    function addUserKycInfo(string memory _firstName,
                      string memory _lastName,
                      string memory _gender,
                      string memory _dob,
                      string memory _aadhaarNumber,
                      string memory _aadhaarFrontURL,
                      string memory _aadhaarBackURL,
                      string memory _selfieURL,
                      string memory _createDate) public {

    //Condition to check if this address already has some kycInfo

    userKycMap[msg.sender] = userKycInfo(_firstName, _lastName, _gender, _dob, _aadhaarNumber, _aadhaarFrontURL, _aadhaarBackURL, _selfieURL, _createDate);
  }

    function getUserKycInfo(address _add) public view returns(userKycInfo memory){
    return userKycMap[_add];
  }

  function addContract(string memory _category,
                      string memory _desc,
                      string memory _name,
                      string memory _email,
                      string memory _st_date,
                      string memory _end_date,
                      string memory _createdate,
                      string memory _SHA256,
                      string memory _IPFSURI,
                      address[] memory _addresses,
                      string[] memory _emails
                      ) public payable {

    //require(!isContractPaused, 'Contract is paused.');
    require(bytes(_SHA256).length >= 0, 'Invalid Document Code.');
    require(msg.value >= ContractCreatePrice, 'Not Enough Funds!');
    require(bytes(ContractsMap[_SHA256].Category).length == 0, 'Document already exists.');

    ContractsMap[_SHA256] = structContractInfo(_category,_desc, _name, _email, _st_date, _end_date, _createdate, _IPFSURI);
    ContractCreatorMap[msg.sender].push(_SHA256);

    addressesInvoledInContractMap[_SHA256].push(msg.sender);
    emailsInvolvedInContractMap[_SHA256].push(_email);
    isConfirmed[msg.sender][_SHA256] = true;

    populateMaps(_addresses,_emails,_SHA256);
    //DailyContractCount[_createdate] += 1;
  }

 function populateMaps(address[] memory _addresses, string[] memory _emails, string memory _sha256) private {
        for (uint i = 0; i < _addresses.length; i++) {
            address user = _addresses[i];
            string memory email = _emails[i];
            require(user != address(0), "invalid user address");
            require(user != msg.sender, "can't use owner as participants");
            addressesInvoledInContractMap[_sha256].push(user);
            emailsInvolvedInContractMap[_sha256].push(email);
            signatureNeededMap[user].push( _sha256);
            isConfirmed[user][_sha256] = false;
        }
  }

  function getContractInfo(string memory _sha256) public view returns ( address[] memory, string[] memory, bool[] memory, bool, bool) {
        address[] memory allUsers = addressesInvoledInContractMap[_sha256];
        string[] memory allEmails = emailsInvolvedInContractMap[_sha256];
        bool[] memory statuses = new bool[](allUsers.length);
        bool isAllSigned = true;
        bool isSelfSigned = isConfirmed[msg.sender][_sha256];
        for (uint i = 0; i < allUsers.length; i++) {
            address user = allUsers[i];
            statuses[i] = isConfirmed[user][_sha256];
            if (!isConfirmed[user][_sha256]){
              isAllSigned = false;
            }
        }
        return (allUsers, allEmails, statuses ,isAllSigned, isSelfSigned);
    }

  function getContractsCount_address(address _add) public view returns ( uint256 ) {
    return ContractCreatorMap[_add].length;
  }

  function getContract(string memory _SHA256) public view returns ( structContractInfo memory ) {
    return ContractsMap[_SHA256];
  }

    function getAllInvitedContracts() public view returns (string[] memory) {
        return signatureNeededMap[msg.sender];
    }

  function getContractbyCreator() public view returns ( string[] memory ) {
      return ContractCreatorMap[msg.sender];
  }

        //accept invite
    function approveTransaction(string memory _sha256) public {
        isConfirmed[msg.sender][_sha256] = true;
    }












    //   function getContractsCount_date(string memory _createdate) public view returns ( uint256 ) {
    //     return DailyContractCount[_createdate];
    //   }

    //   function getContractBalance() public view returns ( uint256 ) {
    //     return(address(this).balance);
    //   }


    //   function withdraw() public onlyOwner {
    //     (bool os, ) = payable(owner()).call{value: address(this).balance}('');
    //     require(os);
    //   }

    //   mapping(address => uint256) internal OrgOwners;
    //   mapping(string => uint256) internal DailyContractCount;
    //   bool public isContractPaused = false;


    //   constructor(
    //   ) {
    //     OrgOwners[_msgSender()] = 1;
    //   }

    
    //   function isOrgOwner(address _add) public view returns (bool) {
    //     return OrgOwners[_add] > 0
    //         ? true
    //         : false;
    //   }


    //   function addOrgOwner(address _orgOwner) public onlyOwner {
    //      OrgOwners[_orgOwner] = 1;
    //   }

    //   function setContractState(bool _pauseState) public onlyOwner {
    //     isContractPaused = _pauseState;
    //   }

    //   function setPrice(uint256 _price) public onlyOwner {
    //     // price can be set to 0
    //     ContractCreatePrice = _price;
    //   }



  fallback() external  {
  }

  
}